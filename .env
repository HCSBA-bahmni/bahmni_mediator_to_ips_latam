// index.js — Terminology Mediator (ESM, Node 20+)
import 'dotenv/config';
import express from 'express';
import axios from 'axios';
import https from 'https';
import fs from 'fs';
import path from 'path';
import crypto, { randomUUID } from 'crypto';
import { registerMediator, activateHeartbeat } from 'openhim-mediator-utils';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);
let mediatorConfig = null;
try {
  mediatorConfig = require('./mediatorConfig.json');
} catch (_) { /* opcional: sin registro OpenHIM */ }

// ===================== ENV =====================
const {
  NODE_ENV = 'production',
  PORT = 8010,

  // URLs:
  // - PUBLIC_BASE_URL: dónde los clientes llaman al mediador (p. ej., vía OpenHIM)
  // - TS_BASE_URL:     a dónde el mediador proxifica (Snowstorm/HAPI FHIR Terminology)
  TERMINOLOGY_BASE_URL,
  TERMINO_SERVER_URL,

  // TLS / certs
  ALLOW_SELF_SIGNED = 'false',
  SSL_KEY_PATH,
  SSL_CERT_PATH,

  // CORS opcional
  CORS_ORIGIN = '*',

  // OpenHIM opcional
  OPENHIM_API,
  OPENHIM_USER,
  OPENHIM_PASS,
} = process.env;

const PUBLIC_BASE_URL = (TERMINOLOGY_BASE_URL || '').replace(/\/+$/, '');
const TS_BASE_URL = (TERMINO_SERVER_URL || '').replace(/\/+$/, '');

const DEV_MODE = NODE_ENV !== 'production' || ALLOW_SELF_SIGNED === 'true';

// ===================== App =====================
const app = express();
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: true }));

// CORS básico
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', CORS_ORIGIN);
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', '*, content-type, x-correlation-id');
  if (req.method === 'OPTIONS') return res.sendStatus(204);
  next();
});

// Correlation ID
app.use((req, _res, next) => {
  req.correlationId = req.headers['x-correlation-id'] || randomUUID();
  next();
});

// HTTPS Agent (self-signed)
function makeAgent() {
  if (!DEV_MODE) return undefined;
  const opts = { rejectUnauthorized: false };
  if (SSL_KEY_PATH && SSL_CERT_PATH && fs.existsSync(SSL_KEY_PATH) && fs.existsSync(SSL_CERT_PATH)) {
    opts.key = fs.readFileSync(path.resolve(SSL_KEY_PATH));
    opts.cert = fs.readFileSync(path.resolve(SSL_CERT_PATH));
  }
  return new https.Agent(opts);
}

if (DEV_MODE) {
  console.warn('⚠ DEV MODE: accepting self-signed certificates');
}

// ===================== Health =====================
app.get('/termino/_health', (_req, res) => {
  res.json({
    status: 'ok',
    env: NODE_ENV,
    publicBase: PUBLIC_BASE_URL || null,
    tsBase: TS_BASE_URL || null,
    tsReachable: Boolean(TS_BASE_URL),
    tsProtocol: TS_BASE_URL.startsWith('https') ? 'https' : 'http',
    tsHostname: (() => {
      try { return new URL(TS_BASE_URL).hostname; } catch { return null; }
    })(),
    tsPath: (() => {
      try { return new URL(TS_BASE_URL).pathname; } catch { return null; }
    })(),
    tsAgent: DEV_MODE ? 'insecure' : 'default',
    tsTime: new Date().toISOString(),
  });
});

// ===================== Helpers =====================
async function forwardTsOperation(resource, operation, req, res) {
  try {
    if (!TS_BASE_URL) throw new Error('TS_BASE_URL (TERMINO_SERVER_URL) is not set');
    const url = `${TS_BASE_URL}/${resource}/${operation}`;
    const params = new URLSearchParams(req.query || {});
    const agent = makeAgent();

    // FHIR $operations se envían como POST application/x-www-form-urlencoded
    console.log(`[${req.correlationId}] → TS POST ${url} body=${params.toString()}`);
    const response = await axios.post(url, params, {
      httpsAgent: agent,
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      // timeout opcional si lo necesitas:
      // timeout: 15000,
    });
    res.status(response.status).json(response.data);
  } catch (err) {
    console.error(`[${req.correlationId}] ❌ TS operation error:`, err?.message || err);
    res.status(502).json({
      resourceType: 'OperationOutcome',
      issue: [{ severity: 'error', code: 'exception', diagnostics: err?.message || String(err) }],
    });
  }
}

// ===================== Rutas $operation (escapando $) =====================
// CodeSystem $lookup
app.get(/^\/termino\/fhir\/CodeSystem\/\$lookup$/, (req, res) =>
  forwardTsOperation('CodeSystem', '$lookup', req, res)
);

// CodeSystem $validate-code
app.get(/^\/termino\/fhir\/CodeSystem\/\$validate-code$/, (req, res) =>
  forwardTsOperation('CodeSystem', '$validate-code', req, res)
);

// ValueSet $validate-code
app.get(/^\/termino\/fhir\/ValueSet\/\$validate-code$/, (req, res) =>
  forwardTsOperation('ValueSet', '$validate-code', req, res)
);

// ConceptMap $translate
app.get(/^\/termino\/fhir\/ConceptMap\/\$translate$/, (req, res) =>
  forwardTsOperation('ConceptMap', '$translate', req, res)
);

// ===================== Catch-all proxy GET (recursos REST) =====================
app.get('/termino/fhir/*', async (req, res) => {
  try {
    if (!TS_BASE_URL) throw new Error('TS_BASE_URL (TERMINO_SERVER_URL) is not set');
    const tail = req.params[0] || '';
    const url = `${TS_BASE_URL}/${tail}`.replace(/\/+$/, '');
    const agent = makeAgent();
    const qs = req._parsedUrl?.search || '';
    console.log(`[${req.correlationId}] → TS GET ${url}${qs}`);
    const response = await axios.get(url, { httpsAgent: agent, params: req.query });
    res.status(response.status).json(response.data);
  } catch (err) {
    console.error('❌ TS proxy error:', err?.message || err);
    res.status(502).json({
      resourceType: 'OperationOutcome',
      issue: [{ severity: 'error', code: 'exception', diagnostics: err?.message || String(err) }],
    });
  }
});

// ===================== OpenHIM (opcional) =====================
async function maybeRegisterWithOpenHIM() {
  if (!OPENHIM_API || !OPENHIM_USER || !OPENHIM_PASS || !mediatorConfig) return;
  try {
    await registerMediator(
      {
        apiURL: OPENHIM_API.replace(/\/+$/, ''),
        username: OPENHIM_USER,
        password: OPENHIM_PASS,
        trustSelfSigned: DEV_MODE,
      },
      mediatorConfig
    );
    activateHeartbeat(
      {
        apiURL: OPENHIM_API.replace(/\/+$/, ''),
        username: OPENHIM_USER,
        password: OPENHIM_PASS,
        trustSelfSigned: DEV_MODE,
      },
      mediatorConfig
    );
    console.log('✓ OpenHIM registration/heartbeat active');
  } catch (e) {
    console.warn('⚠ OpenHIM registration failed:', e?.message || e);
  }
}

// ===================== Start =====================
app.listen(PORT, async () => {
  console.log(`Terminology Mediator listening on port ${PORT}`);
  if (PUBLIC_BASE_URL) console.log(`→ Public base (mediator): ${PUBLIC_BASE_URL}`);
  console.log(`→ TS base: ${TS_BASE_URL}`);
  await maybeRegisterWithOpenHIM();
});
